# Example ESPHome configuration for Fossibot Battery Monitor
# 
# This configuration connects to a Fossibot battery via BLE and exposes
# battery state, power readings, and control switches to Home Assistant.

substitutions:
  device_name: fbot-battery
  friendly_name: "Fbot Battery"

esphome:
  name: ${device_name}
  platform: ESP32
  board: esp32dev

# Enable logging
logger:
  level: DEBUG

# Enable Home Assistant API
api:
  encryption:
    key: "YOUR_ENCRYPTION_KEY_HERE"

# Enable OTA updates
ota:
  password: "YOUR_OTA_PASSWORD_HERE"

# WiFi configuration
wifi:
  ssid: "YOUR_WIFI_SSID"
  password: "YOUR_WIFI_PASSWORD"
  
  # Enable fallback hotspot
  ap:
    ssid: "${device_name} Fallback"
    password: "fallback_password"

# Captive portal for easy WiFi setup
captive_portal:

# Load external component
external_components:
  - source: github://ylianst/esp-fbot
    refresh: 10s

# BLE Client configuration
ble_client:
  - mac_address: "AA:BB:CC:DD:EE:FF"  # Replace with your battery Bluetooth LE MAC address
    id: fbot_ble_client

# Configure the Fbot component
fbot:
  - ble_client_id: fbot_ble_client
    id: my_fbot
    polling_interval: 2s  # How often to poll for updates (default: 2s)

# Binary sensors for connection and output states
binary_sensor:
  - platform: fbot
    fbot_id: my_fbot
    connected:
      name: "${friendly_name} Connected"
    usb_active:
      name: "${friendly_name} USB Active"
    dc_active:
      name: "${friendly_name} DC Active"
    ac_active:
      name: "${friendly_name} AC Inverter Active"
    light_active:
      name: "${friendly_name} Light Active"

# Sensors for battery and power readings
sensor:
  - platform: fbot
    fbot_id: my_fbot
    battery_level:
      name: "${friendly_name} Battery"
      id: battery_percent
    battery_s1_level:
      name: "${friendly_name} Battery"
      id: battery_percent_s1
    battery_s2_level:
      name: "${friendly_name} Battery"
      id: battery_percent_s2
    input_power:
      name: "${friendly_name} Input Power"
      id: input_watts
    output_power:
      name: "${friendly_name} Output Power"
      id: output_watts
    system_power:
      name: "${friendly_name} System Power"
      id: system_watts
    total_power:
      name: "${friendly_name} Total Power"
      id: total_watts
    remaining_time:
      name: "${friendly_name} Remaining Time"
      id: remaining_minutes

  # WiFi Signal Strength
  - platform: wifi_signal
    name: "${friendly_name} WiFi Signal"
    update_interval: 60s

  # Uptime sensor
  - platform: uptime
    name: "${friendly_name} Uptime"
    update_interval: 60s

# Switches to control outputs
switch:
  - platform: fbot
    fbot_id: my_fbot
    usb:
      name: "${friendly_name} USB Output"
      id: usb_switch
    dc:
      name: "${friendly_name} DC Output"
      id: dc_switch
    ac:
      name: "${friendly_name} AC Inverter"
      id: ac_switch
    light:
      name: "${friendly_name} Light"
      id: light_switch

  # Restart switch
  - platform: restart
    name: "${friendly_name} Restart"

# Text sensors for diagnostics
text_sensor:
  - platform: wifi_info
    ip_address:
      name: "${friendly_name} IP Address"
    ssid:
      name: "${friendly_name} Connected SSID"
    bssid:
      name: "${friendly_name} Connected BSSID"
    mac_address:
      name: "${friendly_name} MAC Address"

# Optional: Create template sensors for more useful values
# Uncomment if you want these additional calculated sensors
#
# sensor:
#   # Convert remaining time from minutes to hours
#   - platform: template
#     name: "${friendly_name} Remaining Hours"
#     lambda: |-
#       if (id(remaining_minutes).has_state()) {
#         return id(remaining_minutes).state / 60.0;
#       }
#       return 0.0;
#     unit_of_measurement: "h"
#     accuracy_decimals: 1
#     device_class: duration
#     state_class: measurement
#     update_interval: 2s
#
#   # Net power (positive = charging, negative = discharging)
#   - platform: template
#     name: "${friendly_name} Net Power"
#     lambda: |-
#       if (id(input_watts).has_state() && id(output_watts).has_state()) {
#         return id(input_watts).state - id(output_watts).state;
#       }
#       return 0.0;
#     unit_of_measurement: "W"
#     accuracy_decimals: 0
#     device_class: power
#     state_class: measurement
#     update_interval: 2s
